\documentclass[12pt,a4paper,oneside]{article}

\usepackage{textcase}
\usepackage[]{graphicx}

\linespread{1.5}

%Russian-specific packages
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

%algorithms
\usepackage{float}
\usepackage[boxed,vlined,ruled]{algorithm2e}

% sections
\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}
\renewcommand{\thesection}{\arabic{section}}

\usepackage{lipsum}
\usepackage[margin=2cm,left=3cm,right=15mm,includefoot]{geometry}

% theorems
\usepackage{amsthm}
\newtheorem{theorem}{Теорема}

\theoremstyle{definition}
\newtheorem{definition}{Определение}[]

\theoremstyle{lemma}
\newtheorem{lemma}{Утверждение}[]

\theoremstyle{remark}
\newtheorem{remark}{Замечание}[]

\begin{document}
\begin{titlepage}
        \begin{center}

        \bigskip

        \MakeTextUppercase{Московский государственный университет им. М.В. Ломоносова} \\

        \bigskip

        \includegraphics[width=50mm]{msu.eps}

        \bigskip
        \MakeTextUppercase{Факультет вычислительной математики и кибернетики} \\
        \MakeTextUppercase{Кафедра суперкомпьютеров и квантовой информатики} \\
        \bigskip
        \bigskip
        \MakeTextUppercase{\textbf{\Huge Магистерская диссертация}} \\
        \bigskip
        {\large на тему:} \\
        \bigskip
        \MakeTextUppercase{\textbf{\large Алгоритмы поиска подграфов типа "черная дыра" в ориентированном графе}}

        \bigskip
        Шифр и наименование специальности

    \end{center}

    \bigskip
    \bigskip
    \bigskip
    \begin{flushright}
        \begin{minipage}{7cm}
            \textbf{Выполнил:} \\
            студент гр. М-218 \\
            Иванов Денис Евгеньевич \\

            \textbf{Научный руководитель:} \\
            к.т.н. Семенов Александр Сергеевич \\

            \textbf{Рецензент:} \\
            ??????? ??????? ???????
        \end{minipage}
    \end{flushright}

    \vfill

    \begin{center}
    {\large Москва, 2020}
    \end{center}

\end{titlepage}

\setcounter{page}{2}

\tableofcontents
\addcontentsline{toc}{section}{Содержание}

\cleardoublepage
\section{Введение}\label{sec:otherintro}
Одним из важных свойств графов, которые описывают объекты реального мира,
является образование в них кластеров или сообществ.

Задача поиска этих сообществ имеет важное значение в социологии, биологии и компьютерных науках,
поскольку объекты, изучаемые в данных прикладных областях, часто естественно моделируются при
помощи графов. \cite{fortunato2010community}

В работе \cite{li2010detecting} впервые сформулирована задача поиска подграфов (паттернов) типа "черная дыра" и "вулкан" в больших ориентированных графах. В соответствии с этой работой, черная дыра - множество вершин графа, в которого отсутствуют исходящие ребра. Вулкан - это, наоборот, множество вершин графа, у которого имеются только исходящие ребра.

Паттерны черная дыра и вулкан встречаются в прикладных задачах. Например, в торговой сети, паттерн черная дыра может представлоять собой группу торговцев, которые манипулируют рынком. Также, черная дыра и вулкан могут описывать собой схемы отмывания денег \cite{semenov2017survey}. Поиск черных дыр и вулканов в реальном времени может  своевременно обнаружить пагубные явления, такие как природные катаклизмы, катастрофы, происшествия. Разработка алгоритмов поиска таких паттернов позволяет сохранять общественную безопасность. \cite{hong2015detecting}

Основной вклад в исследование задачи поиска паттерна черная дыра внелса группа авторов из университета Нью-Джерси. Они сформулировали задачу и предложили аалгоритм поиса ч ерных дыр в случае невзвешенного ориентированного графа \cite{li2010detecting}. Два  года спустя эти же авторы опубликовали алгоритм для приближенного поиска черных дыр в случае взвешенного графа \cite{li2012mining,li2014mining}. Hong \cite{hong2015detecting} рассматривает задачу поиска черных дыр в реальном времени для  нужд современного города. В этой работе предлагается оригинальный алгоритм, приближенно решающий задачу для динамических графов.

В данной работе мы рассматриваем упрощенную поставновку задачи поиска черных дыр для случая ориентированного графа без весов.

\cleardoublepage
\section{Постановка задачи}\label{sec:taskstatement}

Рассмотрим граф $G = G(V,E)$, где $V$ - множество вершин, а $E$ - множество ребер.

\begin{definition}\label{def:blackhole}
Подмножество вершин $B \subseteq V$ называется черной дырой, если одновременно выполняются следующие условия: 1) подграф $G'(B,E')$ слабо связан и 2) нет такой пары вершин $(u,v)$ что $u \in B,\ v \in V\setminus{B};\ (u,v) \in E$.
\end{definition}

Задача состоит в том, чтобы в ориентированном графе без весова найти как можно больше черных дыр (или рассмотреть максимальное количество кандидатов) за ограниченное время.

\cleardoublepage
\section{Определения}\label{sec:definitions}

Введем несколько дополнительных определений.

\begin{definition}\label{def:orpath}
Пусть дан ориентированный граф $G(V,E)$. Последовательность $v_0v_1v_2...v_k$, состоящая из вершин $v_i \in V,\ 0 \leq i \leq k$ образует ориентированный путь из $v_0$ в $v_k$, если существуют ребра $(v_{i-1}, v_i) \in E,\ 1 \leq i \leq k$ и $v_i \neq v_j$ для всех $0 \leq i,\ j \leq k,\ i \neq j$. Длина такого ориентированного пути равна $k$.
\end{definition}

\begin{definition}\label{def:reachablevertex}
Пусть дан ориентированный граф $G(V,E)$. Вершина $v \in V$ достижима из $u \in V$, если существует ориентированный путь, который начинается в $u$ и заканчивается в $v$.
\end{definition}

\begin{definition}\label{def:successor}
Пусть дан ориентированный граф $G(V,E)$. Если вершина $v \in V$ достижима из $u \in V$ тогда $u$ является ориентированным предком $v$, а $v$ является ориентированным потомком $u$. Если существует ребро из $u$ в $v$, то $u$ является непосредственным предком $v$ , а $v$ является непосредственным потомком $u$.
\end{definition}

\begin{definition}\label{def:scc}
Подмножество вершин $B \subseteq G$ называется компонентой сильной связности (КСС), если все вершины $B$ попарно взаимно достижимы.
\end{definition}

\begin{definition}\label{def:closure}
Пусть дан ориентированный граф $G(V,E)$. Рассмотрим вершину $v \in V$. Замыкание вершины $Closure(v)\ =\ \{u\ |\ u$ достижима из $v\} \cup {v}$.
Другими словами, замыкание вершины $v$ --- это множество всех вершин, достижимых из $v$, включая ее саму.
\end{definition}

Следующие утверждения были ранее доказаны в статье \cite{li2010detecting}.

\begin{lemma}
Если вершина $v \in B$, причем $B \subseteq V$ --- черная дыра, то все потомки $v$ лежат в $B$.
\end{lemma}

\begin{lemma}
Если вершина $v \in B$, причем $B \subseteq V$ --- черная дыра, то замыкание $v$ полностью содержится в $B$.
\end{lemma}

\begin{lemma}
Замыкание любой вершины образует черную дыру.
\end{lemma}

\cleardoublepage
\section{Известные проблемы}\label{sec:knownissues}

В данном разделе рассматривается применимость алгоритма iBlackhole, предложенного в статье \cite{li2010detecting}. Алгоритм \ref{alg:iblackhole} создан для поиска черных дыр фиксированного размера. Он имеет значительный ресурс параллелизма, однако в работе \cite{li2010detecting} не рассматривается случай больших графов: практические исследования проводятся на графах, размерх которых не превышает 1500 вершин.

Далее мы вводим дополнительное утверждение, чтобы описать проблемы существующего подхода.

\begin{lemma}{}
Все вершины КСС принадлежат черной дыре.
\end{lemma}
\begin{proof}
В КСС все вершины попарно взаимно достижимы. Это значит, что замыкание произвольной вершины КСС $ $ содержит всю КСС как подмножество. Опираясь на Лемму 3 FIXME, получаем, что КСС принадлежит той же черной дыре, что и вершина $v$.
\end{proof}

Существуют графы, которые имеют сравнительно небольшое количество черных дыр относительно общего количества вершин. Они состоят из нескольких больших КСС и относительно малого числа независимых листьев или корней. В связи с этим возникает два вопроса по поводу применимости алгоритма iBlackhole:

    - Как узнать, что в графе содержатся черные дыры заданного размера? В общем случае, необходимо проверить все возможные размеры, что займет много времени даже в параллельном режиме.

    - Как можно сократить область поиска на стадии полного перебора и избежать повторных проверок комбинаций вершин?

Рассмотрим следующий пример. Граф состоит из $10^6$ вершин, которые образуют единую КСС. Это значит, что в данном графе существует только одна черная дыра - это весь граф. Пока мы не знаем ничего о структуре графа и не обладаем достаточно большими вычислительными ресурсами, необходимо будет перебирать слишком большое число возможных размеров черных дыр. В худшем случае нам придется перебрать все возможные размеры графа.

Другой пример - это гафы малого мира \cite{watts1999networks}. Большая часть вершин такого графа содержится в единственной большой КСС, Также имеется несколько вершин и корней. Мы утверждаем, что при просмотре от меньших размеров черной дыры к большим, алгоритм iBlackhole быстро обнаружит все небольшие черные дыры. далее он будет очень долго пытаться найти черные дыры внутри КССА, где их попросту нет, пока не доберется до размеров больше размера КСС.

\cleardoublepage
\section{Разработка топологического алгоритма}\label{sec:topalgodesign}

Мы предлагаем рассмотреть решение задачи поиска черных дыр при помощи комбинации двух этапов. Первый этап состоит в предобработке графа, задача которой упростить структуру граффа настолько, насколько это возможно. Уменьшение размера графа значительно сокращает вычисления, которые в худшем случае являются собой полный перебор вариантов. Второй этап - это непосредственно поиск черных дыр. Целью данного этапа является обнаружение как можно большего числа черных дыр при заданном ограничении по времени.

\subsection{Предобработка графа}\label{subsec:graphpreprocessing}

Как было сказано выше, большие КСС требуют значительных вычислительных ресурсов для обработки и при этом не образуеют дополнительных черных дыр. Это может быть критично при обработке графов малого мира, потому что одна КСС может включать до 100\% вершин некоторого графа. В таком случае будет удобно рассмотреть КСС как единую вершину, которая объединяет в себе все входящие и исходящие связи периферических вершин КСС, На стадии предобработки происходит сжатие каждой КСС до единственной вершины. Процесс такого сжатия известен как конденсация графа.

 некоторого графа. В таком случае будет удобно рассмотреть КСС как единую вершину, которая объединяет в себе все входящие и исходящие связи периферических вершин КСС, На стадии предобработки происходит сжатие каждой КСС до единственной вершины. Процесс такого сжатия известен как конденсация графа.

\begin{definition}\label{def:condensation}
Если каждую компоненту сильной связности заменить единственной вершиной, то получится ориентированный ациклический граф, который называется конденсацией исходного графа.
\end{definition}

В данной работе мы используем алгоритм Шарира для конденсации графа \cite{sharir1981strong}

\subsection{Поиск черных дыр}

После предобработки графа происходит переход к этапу поиска черных дыр. Задача имеет комбинаторную природуФ, поэтому на данном этапе основная задача - это уменьшить число потенциальных кандидатов. Опишем сначала подход, основанный на полном переборе вершин.


\begin{definition}\label{def:blackholeroot}
Корень черной дыры $B \subseteq V$ --- это такая вершина $v \in B$, что не найдется ребра $(u, v) \in E$, где $u \in B,\ u \neq v$.
\end{definition}

\begin{definition}\label{def:blackholebasis}
Множество всех корней черной дыры называется базисом черной дыры.
\end{definition}

Отметим, что базис черной дыры может состоять из произвольного числа вершин, отличного от нуля.

Во время полного перебора мы просматриваем все возмоные неупорядоченные подмножества вершин графа. Далее для каждой вершины очередного подмножества мы получаем ее замыкание. Объединение всех таких замыканий является кандидатом, потенциальной черной дырой. Если кандидат является слабо связным подграфом, тогда это черная дыра.

Такой подход не застрахован от повторного обнаружения уже известной черной дыры. Для уменьшения количества повторного обнаружения уже известных дыр мы вводим эвристику.

Согласно определениям, данным выш, если какая-то вершина не является корнем черной дыры, то тона может быть опущена, так как набор корней описывает черную дыру единственным образом. Каждая не корневая вершина в черной дыре достижима из какого-то корня черной дыры. Значит, если мы располагаем матрицей попарной достижимости для данного графа, то мы можем эффективно определять лишние, не являющиеся базисами, комбинации вершин. Конечно же, мы могли бы прямо вычислить такую матрицу достижимости, но это вычислительно сложная задача $O(V^3)$, что не позволяет применить такое правилодля больших графов. Мы можем столкнуться с нехваткой как памяти, так и времени  на предобработку. Надо отметить, что неплохо бы получить первые черные дыры как можно скорее после старта, что ограничивает нас в использовании особенно дорогих вычислений. Поэтому мы воспользуемся эвристикой, которая является частным случаем описанного правила, чтобы частично сократить поле перебора, не жертвую временем первого ответа. Те дубликаты, которые не могут быть отфильтроаны эвристикой, будут проверены "в лоб".

Далее мы описываем идею топологической сортировки графа.

\begin{definition}
Топологоческая сортировка или топологическое упорядочивание ациклического орграфа --- такой массив вершин, что для любого ребра $(u,v) \in E$ вершина $v$ будет иметь индекс меньше, чем $u$.
\end{definition}

\begin{definition}
Пусть дан ориентированный граф $G(V,E)$, корень $r \in Roots(G),\ topSortOrder_r$ --- топологическая сортировка замыкания $Closure(r)$ и $|Closure(v)|$ --- размеры замыканий для всех вершин $v \in Closure(r)$, то есть доступных из $r$. Вершина называется особой вершиной под корнем $r$, если размер ее замыкания $|Closure(v)|$ равен ее индексу в массиве $topSortOrder_r$ плюс один.
\end{definition}

\begin{remark}
Заметим, что множество $Special_r$ особых вершин под корнем $r$ полностью содержится в замыкании данного корня, то есть $Special_r \subseteq Closure(r)$
\end{remark}

\begin{remark}
Решение о том, является ли вершины особой, принимается независимо в поддереве каждого корня. Одна и та же вершина может быть особой в поддереве одного корня и не являться таковой в поддереве другого корня. Пример такой ситуации отображен на Рисунке 1.
\end{remark}

\begin{definition}
Пусть дан ориентированный граф $G(V,E)$, один из его корней $r \in Roots(G)$, $topSortOrder_r$ --- топологическая сортировка замыкания $Closure(r)$, $v \in Special_r$ и $u \in Closure(r)$. Вершина $v$ доминирует над вершиной $u$ под корнем $r$, если $v$ имеет больший индекс, чем $u$ в массиве $topSortOrder_r$.
\end{definition}

\begin{remark}
Если дано две особых вершины под одним корнем, то одна из них всегда будет доминировать над другой.
\end{remark}

\begin{theorem}
Пусть дан ориентированный граф $G(V,E)$, один из его корней $r \in Roots(G)$, $v \in Special_r$, $u \in Closure(r)$. Если $v$ доминирует над $u$ под корнем $r$, значит $u$ достижима из $v$.
\end{theorem}

\begin{proof}
По определению особой вершины размер замыкания $v$ равен ее индексу плюс один в $topSortOrder_r$. Рассмотрим все вершины, отличные от $v$ в замыкании $Closure(v)$. Эти вершины в массиве $topSortOrder_r$ имеют индексы меньше, чем вершина $v$. Отсюда $\forall u \in Closure(v)$ вершины $u$ будет достижима из $v$.
\end{proof}

\begin{theorem}
Пусть дан ориентированный граф $G(V,E)$, один из его корней $r \in Roots(G)$, $v \in Special_r$, $u \in Closure(r)$. Если $v$ доминирует над $u$ под корнем $r$, значит $Closure(v) \cup Closure(u) = Closure(v)$.
\end{theorem}

\begin{proof}
Согласно предыдущей теореме, если $v$ доминирует над $u$ под корнем $r$, то вершина $u$ будет достижима из $v$. Тогда $u \in Closure(v)$ откуда следует $Closure(u) \subseteq Closure(v)$.
\end{proof}

\begin{definition}
Те вершины графа $G(V,E)$, которые не имеют входящих ребер, называются глобальными корнями.
\end{definition}

Рассмотрим две вершины в замыкании глобального корня. Одна з них особая, а другая обычная. Чтобы эти две вершины образовали базис, особая вершины не должна доминировать над обычной. В противном случае обычная вершина могла бы быть опущена как незначимая. В общем случае, если дан набор вершин, мы можем опустить все доминируемые вершины и получить корректный базис.

\linespread{1.0}
\begin{figure}[H]
	\begin{center}
		\begin{algorithm}[H]
			\SetAlgoLined
			\SetKwInOut{Input}{Input}
			\SetKwInOut{Output}{Output}
			\Input{$G(v, E)$ -- ориентированный граф, $V$ -- множество вершин, $E$ -- множество ребер, \\
                   $n$ -- максимальное число вершин, которое может содержать черная дыра}
			\Output{$Blackholes$ -- множество всех черных дыр графа размером от 1 до n}

                        $Blackholes = \emptyset, C_0 = \emptyset$ \\
                        \For{$i = 1\ to\ n$} {
                            $P_i = \{v | d_{out}(v) < i\}$
                            \tcp*[f]{$d_{out}(v)$ количество исходящих из $v$ ребер} \\
                            \ForEach{$v \in P_i$} {
                                \If{$v \notin C_{i-1}$} {
                                    \If{как минимум один из непосредственных потомков $v$ не принадлежит $P_i$} {
                                        удалить $v$ из $P_i$\\
                                        удалить вcех предков $v$ из $P_i$ \\
                                    }
                                }
                            }
                        }
                        $C_i = P_i$  \tcp*[f]{$C_i$ -- список кандидатов} \\
                        \ForEach{$v \in C_i$} {
                            \If{$|Closure(v)| == i$} {
                                $Blackholes = Blackholes \cup Closure(v)$
                            }
                            \If{$|Closure(v)| >= i$} {
                                удалить $v$ из $С_i$\\
                                удалить вcех предков $v$ из $С_i$ \\
                            }
                        }
                        \tcc{Применить алгоритм полного перебора к $C_i(i)$ -- множеству всех подмножеств $C_i$, содержащих $i$ вершин}
                        \ForEach{$B \in C_i(i)$} {
                            \If{$G(B)$ -- слабо связан} {
                                \If{$d_{out}(B) == 0$} {
                                    $Blackholes = Blackholes \cup B$ \\
                                }
                            }
                        }
                        \Return $Blackholes$
			\label{alg:iblackhole}
			\caption{iBlackhole}
		\end{algorithm}
	\end{center}
\end{figure}
\linespread{1.5}

\linespread{1.0}
\begin{figure}[H]
	\begin{center}
		\begin{algorithm}[H]
			\SetAlgoLined
			\SetKwInOut{Input}{Input}
			\SetKwInOut{Output}{Output}
			\Input{$G(V,E)$ -- ориентированный граф}
			\Output{$Blackholes$ -- множество черных дыр разных размеров}

                        $Blackhole = \emptyset$\\
                        Построить граф конденсацию $Cond(V',E')$ \\
                        \For{$i = 1\ to\ |V'|$} {
                            \ForEach{$B_i \in V'(i)$} {
                                \If{$IsBasis(Cond(V',E'),B_i)$} {
                                    \If{$B_i$ -- слабо связан} {
                                        $Blackholes = Blackholes \cup B_i$ \\
                                    }
                                }
                            }
                        }
                        \Return $Blackholes$
			\label{alg:topsort}
			\caption{TopSort}
		\end{algorithm}
	\end{center}
\end{figure}
\linespread{1.5}

\linespread{1.0}
\begin{figure}[H]
	\begin{center}
		\begin{algorithm}[H]
			\SetAlgoLined
			\SetKwInOut{Input}{Input}
			\SetKwInOut{Output}{Output}
			\Input{$G(V,E)$ -- ориентированный граф без циклов (граф конденсация) \\
                                $Cand \subset V$ -- множество вершин, потенциальный базис черной дыры}
			\Output{$True$ -- если $Cand$ является базисом черной дыры, $False$ в противном случае}
                        \tcc{(1) определить особые вершины для каждого корня}
                        \ForEach{$r \in Roots(G)$} {
                            $Special_r = \emptyset$ \\
                            $build\ topSortOrder_r$ \\
                            \For{$i = 0; i<|topSortOrder_r|; i=i + 1$} {
                                $v = topSortOrder_r[i]$ \\
                                $C_v = Closure(v)$ \\
                                \If{$|C_v| == i$} {
                                    $Special_r = Special_r \cup v$ \\
                                    $maxSpecialIndex_r = max(maxSpecialIndex_r, i)$ \\
                                }
                            }
                        }
			\tcc{(2) проверить, есть ли доминируемые вершины}
                        \ForEach{$r \in Roots(G)$} {
                            $maxSpecialIndex_r = -1$ \\
                        }
			\ForEach{$v \in Cand$} {
                            \ForEach{$r \in Roots(G)$} {
                                \If{$v \in Special_r$} {
                                    $vTopSortIndex_r = arg_v (topSortOrder_r)$ \\
                                    $maxSpecialIndex_r = max(maxSpecialIndex_r, vTopSortIndex_r)$ \\
                                }
                            }
			}
			\ForEach{$v \in Cand$} {
                            \ForEach{$r \in Roots(G)$} {
                                \If{$v \in Closure(r)$} {
                                    $vTopSortIndex_r = arg_v (topSortOrder_r)$ \\
                                    \If{$vTopSortIndex_r < maxSpecialIndex_r$} {
                                        \Return $False$ \\
                                    }
                                }
                            }
			}
                        \tcc{(3) проверить вершины на взаимную достижимость}
                        \ForEach{$(v, u) \in Cand(G) \times Cand(G)$} {
                            \If{v is reachable from u} {
                                \Return $False$ \\
                            }
                        }
                        \Return $True$
			\label{alg:isbasis}
			\caption{IsBasis}
		\end{algorithm}
	\end{center}
\end{figure}
\linespread{1.5}

Алгоритм \ref{alg:isbasis} (IsBasis)  проверяет, является ли набор вершин базисом. Этот алгоритм принимает набор вершин и возвращается True, если данный набор образует базис и False в противном случае. Этот алгоритм используется как составная часть алгоритма \ref{alg:topsort} (TopSort), который перебирает наборы-кандидаты и отфильтровывает некорректные наборы. Если IsBasis возвращает False для кандидата, то этот набор может быть пропущен.

IsBasis действует следующим образом.

В первую очередь нам нужно знать, какие вершины являются особыми. Этот шаг может быть посчитан заранее. Чтобы определеить особые вершины, мы строим топологическую сортировку замыкания для каждого глобального корня. Далее по определению отмечаем особые вершины.

Вторым шагом, если мы находим, что какие-то вепршины доминируемы, то мы опускаем данный набор вершин.

На третьем шаге закончились дешевые методы принятия решения. Проверяем попарную достижимость вершин в наборе. Если найдется хоть одна такая пара, опускаем данный набор вершин.

Если ни одна из предыдущих проверок не ответила False (Опустить), то IsBasis возвращает True. Это значение возвращается в алгоритм TopSort и означает, что мы имеем дело с корректным базисом черной дыры. Для получения черной дыры мы должно, согласно определению, объединить все замыкания базисных вершин. Последним шагом убедимся, что полученное множество является слабо связным, это будет означать, что мы получили черную дыру.

Очевидно, что процесс не оптимален, но исследования демонстрируют его эффективность. Мы успешно избегаем дорогой проверки на слабую связность в большом количестве случаев.

\cleardoublepage
\section{Результаты эксперимента}\label{sec:experimentalresults}

Чтобы показать эффективность нашего подхода, мы провели серию экспериментов.


\cleardoublepage
\section{Заключение}\label{sec:conclusion}


%
% ---- Bibliography ----
%
\newpage
\bibliographystyle{acm}
\bibliography{biblio}
\addcontentsline{toc}{section}{Список литературы}

\end{document}
