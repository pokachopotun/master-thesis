\documentclass[12pt,a4paper,oneside]{article}

\usepackage{textcase}
\usepackage[]{graphicx}

\linespread{1.5}

%\usepackage{setspace}
%\полуторный интервал
%\onehalfspacing

%Russian-specific packages
%--------------------------------------
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
%--------------------------------------

%algorithms
\usepackage{float}
\usepackage[boxed,vlined,ruled]{algorithm2e}

%\usepackage[russian]{babel}
%\setmainlanguage{russian}
%\setotherlanguage{english}
%\newfontfamily\russianfont[Script=Cyrillic]{Times New Roman}
%\newfontfamily{\cyrillicfont}{Times New Roman}
%\newfontfamily{\cyrillicfonttt}{Times New Roman}

\usepackage{tocloft}
\renewcommand{\cftsecleader}{\cftdotfill{\cftdotsep}}

\renewcommand{\thesection}{\arabic{section}}
%\usepackage[utf8]{inputenc}

\usepackage{lipsum}
\usepackage[margin=2cm,left=3cm,right=15mm,includefoot]{geometry}

% theorems

\usepackage{amsthm}
\newtheorem{theorem}{Теорема}

\theoremstyle{definition}
\newtheorem{definition}{Определение}[]

\theoremstyle{lemma}
\newtheorem{lemma}{Утверждение}[]

\theoremstyle{remark}
\newtheorem{remark}{Замечание}[]

\begin{document}
\begin{titlepage}
        \begin{center}

        \bigskip

        \MakeTextUppercase{Московский государственный университет им. М.В. Ломоносова} \\

        \bigskip

        \includegraphics[width=50mm]{msu.eps}

        \bigskip
        \MakeTextUppercase{Факультет вычислительной математики и кибернетики} \\
        \MakeTextUppercase{Кафедра суперкомпьютеров и квантовой информатики} \\
        \bigskip
        \bigskip
        \MakeTextUppercase{\textbf{\Huge Магистерская диссертация}} \\
        \bigskip
        {\large на тему:} \\
        \bigskip
        \MakeTextUppercase{\textbf{\large Алгоритмы поиска подграфов типа "черная дыра" в ориентированном графе}}

        \bigskip
        Шифр и наименование специальности

    \end{center}

    \bigskip
    \bigskip
    \bigskip
    \begin{flushright}
        \begin{minipage}{7cm}
            \textbf{Выполнил:} \\
            студент гр. М-218 \\
            Иванов Денис Евгеньевич \\

            \textbf{Научный руководитель:} \\
            к.т.н. Семенов Александр Сергеевич \\

            \textbf{Рецензент:} \\
            ??????? ??????? ???????
        \end{minipage}
    \end{flushright}

    \vfill

    \begin{center}
    {\large Москва, 2020}
    \end{center}

\end{titlepage}

\setcounter{page}{2}

\tableofcontents
\addcontentsline{toc}{section}{Содержание}

\cleardoublepage

\section{Введение}\label{sec:otherintro}
Одним из важных свойств графов, которые описывают объекты реального мира,
является образование в них кластеров или сообществ.

Задача поиска этих сообществ имеет важное значение в социологии, биологии и компьютерных науках,
поскольку объекты, изучаемые в данных прикладных областях, часто естественно моделируются при
помощи графов. \cite{fortunato2010community}

В работе \cite{li2010detecting} впервые сформулирована задача поиска подграфов (паттернов) типа "черная дыра" и "вулкан" в больших ориентированных графах. В соответствии с этой работой, черная дыра - множество вершин графа, в которого отсутствуют исходящие ребра. Вулкан - это, наоборот, множество вершин графа, у которого имеются только исходящие ребра.

Паттерны черная дыра и вулкан встречаются в прикладных задачах. Например, в торговой сети, паттерн черная дыра может представлоять собой группу торговцев, которые манипулируют рынком. Также, черная дыра и вулкан могут описывать собой схемы отмывания денег \cite{semenov2017survey}. Поиск черных дыр и вулканов в реальном времени может  своевременно обнаружить пагубные явления, такие как природные катаклизмы, катастрофы, происшествия. Разработка алгоритмов поиска таких паттернов позволяет сохранять общественную безопасность. \cite{hong2015detecting}

Основной вклад в исследование задачи поиска паттерна черная дыра внелса группа авторов из университета Нью-Джерси. Они сформулировали задачу и предложили аалгоритм поиса ч ерных дыр в случае невзвешенного ориентированного графа \cite{li2010detecting}. Два  года спустя эти же авторы опубликовали алгоритм для приближенного поиска черных дыр в случае взвешенного графа \cite{li2012mining,li2014mining}. Hong \cite{hong2015detecting} рассматривает задачу поиска черных дыр в реальном времени для  нужд современного города. В этой работе предлагается оригинальный алгоритм, приближенно решающий задачу для динамических графов.

В данной работе мы рассматриваем упрощенную поставновку задачи поиска черных дыр для случая ориентированного графа без весов.

\section{Постановка задачи}\label{sec:taskstatement}

Рассмотрим граф $G = G(V,E)$, где $V$ - множество вершин, а $E$ - множество ребер.

\begin{definition}
Подмножество вершин $B \subseteq V$ ......
\end{definition}

Задача состоит в том, чтобы в ориентированном графе без весова найти как можно больше черных дыр (или рассмотреть максимальное количество кандидатов) за ограниченное время.

\section{Определения}\label{sec:definitions}

Введем несколько дополнительных определений.

\begin{definition}
Пусть дан ориентированных граф...
\end{definition}

\begin{definition}
Пусть дан ориентированных граф...
\end{definition}

\begin{definition}
Пусть дан ориентированных граф...
\end{definition}

\begin{definition}
Пусть дан ориентированных граф...
\end{definition}

\begin{definition}
Пусть дан ориентированных граф...
\end{definition}

\begin{definition}
Пусть дан ориентированных граф...
\end{definition}

Следующие утверждения были ранее доказаны в статье \cite{li2010detecting}.

\begin{lemma}{}
Пусть дан ориентированных граф...
\end{lemma}

\begin{lemma}{}
Пусть дан ориентированных граф...
\end{lemma}

\begin{lemma}{}
Пусть дан ориентированных граф...
\end{lemma}

\section{Известные проблемы}\label{sec:knownissues}

В данном разделе рассматривается применимость алгоритма iBlackhole, предложенного в статье \cite{li2010detecting}. Алгоритм \ref{alg:iblackhole} создан для поиска черных дыр фиксированного размера. Он имеет значительный ресурс параллелизма, однако в работе \cite{li2010detecting} не рассматривается случай больших графов: практические исследования проводятся на графах, размерх которых не превышает 1500 вершин. 

Далее мы вводим дополнительное утверждение, чтобы описать проблемы существующего подхода.


\begin{lemma}{}
Все вершины КСС принадлежат черной дыре.
\end{lemma}
\begin{proof}
В КСС все вершины попарно взаимно достижимы. Это значит, что замыкание произвольной вершины КСС $ $ содержит всю КСС как подмножество. Опираясь на Лемму 3 FIXME, получаем, что КСС принадлежит той же черной дыре, что и вершина $v$.
\end{proof}

Существуют графы, которые имеют сравнительно небольшое количество черных дыр относительно общего количества вершин. Они состоят из нескольких больших КСС и относительно малого числа независимых листьев или корней. В связи с этим возникает два вопроса по поводу применимости алгоритма iBlackhole:

    - Как узнать, что в графе содержатся черные дыры заданного размера? В общем случае, необходимо проверить все возможные размеры, что займет много времени даже в параллельном режиме.

    - Как можно сократить область поиска на стадии полного перебора и избежать повторных проверок комбинаций вершин?

Рассмотрим следующий пример. Граф состоит из $10^6$ вершин, которые образуют единую КСС. Это значит, что в данном графе существует только одна черная дыра - это весь граф. Пока мы не знаем ничего о структуре графа и не обладаем достаточно большими вычислительными ресурсами, необходимо будет перебирать слишком большое число возможных размеров черных дыр. В худшем случае нам придется перебрать все возможные размеры графа.

Другой пример - это гафы малого мира \cite{watts1999networks}. Большая часть вершин такого графа содержится в единственной большой КСС, Также имеется несколько вершин и корней. Мы утверждаем, что при просмотре от меньших размеров черной дыры к большим, алгоритм iBlackhole быстро обнаружит все небольшие черные дыры. далее он будет очень долго пытаться найти черные дыры внутри КССА, где их попросту нет, пока не доберется до размеров больше размера КСС.

\section{Разработка топологического алгоритма}\label{sec:topalgodesign}

Мы предлагаем рассмотреть решение задачи поиска черных дыр при помощи комбинации двух этапов. Первый этап состоит в предобработке графа, задача которой упростить структуру граффа настолько, насколько это возможно. Уменьшение размера графа значительно сокращает вычисления, которые в худшем случае являются собой полный перебор вариантов. Второй этап - это непосредственно поиск черных дыр. Целью данного этапа является обнаружение как можно большего числа черных дыр при заданном ограничении по времени.

\subsection{Предобработка графа}\label{subsec:graphpreprocessing}

Как было сказано выше, большие КСС требуют значительных вычислительных ресурсов для обработки и при этом не образуеют дополнительных черных дыр. Это может быть критично при обработке графов малого мира, потому что одна КСС может включать до 100\% вершин некоторого графа. В таком случае будет удобно рассмотреть КСС как единую вершину, которая объединяет в себе все входящие и исходящие связи периферических вершин КСС, На стадии предобработки происходит сжатие каждой КСС до единственной вершины. Процесс такого сжатия известен как конденсация графа.

 некоторого графа. В таком случае будет удобно рассмотреть КСС как единую вершину, которая объединяет в себе все входящие и исходящие связи периферических вершин КСС, На стадии предобработки происходит сжатие каждой КСС до единственной вершины. Процесс такого сжатия известен как конденсация графа.

\begin{definition}
Если кажддую компоненту сильно связности заменить единственной вершиной, то получится ориентированный ацикличесикй грфа, который называется конденсацией исходного графа.
\end{definition}

В данной работе мы используем алгоритм Шарира для конденсации графа \cite{sharir1981strong}

\subsection{Поиск черных дыр}

После предобработки графа происходит переход к этапу поиска черных дыр. Задача имеет комбинаторную природуФ, поэтому на данном этапе основная задача - это уменьшить число потенциальных кандидатов. Опишем сначала подход, основанный на полном переборе вершин.


\begin{definition}
Корень черной дырыы......  - это такая вершина, что не найдется ребра...
\end{definition}

\begin{definition}
Множество всех корней черной дыры называется базисом черной дыры.
\end{definition}

Отметим, что базис черной дыры может состоять из произвольного числа вершин, отличного от нуля.

Во время полного перебора мы просматриваем все возмоные неупорядоченные подмножества вершин графа. Далее для каждой вершины очередного подмножества мы получаем ее замыкание. Объединение всех таких замыканий является кандидатом, потенциальной черной дырой. Если кандидат является слабо связным подграфом, тогда это черная дыра.

Такой подход не застрахован от повторного обнаружения уже известной черной дыры. Для уменьшения количества повторного обнаружения уже известных дыр мы вводим эвристику.

Согласно определениям, данным выш, если какая-то вершина не является корнем черной дыры, то тона может быть опущена, так как набор корней описывает черную дыру единственным образом. Каждая не корневая вершина в черной дыре достижима из какого-то корня черной дыры. Значит, если мы располагаем матрицей попарной достижимости для данного графа, то мы можем эффективно определять лишние, не являющиеся базисами, комбинации вершин. Конечно же, мы могли бы прямо вычислить такую матрицу достижимости, но это вычислительно сложная задача $O(V^3)$, что не позволяет применить такое правилодля больших графов. Мы можем столкнуться с нехваткой как памяти, так и времени  на предобработку. Надо отметить, что неплохо бы получить первые черные дыры как можно скорее после старта, что ограничивает нас в использовании особенно дорогих вычислений. Поэтому мы воспользуемся эвристикой, которая является частным случаем описанного правила, чтобы частично сократить поле перебора, не жертвую временем первого ответа. Те дубликаты, которые не могут быть отфильтроаны эвристикой, будут проверены "в лоб".

Далее мы описываем идею топологической сортировки графа.

\begin{definition}
Топологоческая сортировка или топологическое упорядочивание ациклического орграфа - такой массив вершин, что для любого ребра....
\end{definition}

\begin{definition}
Пусть дан ориентированный граф...
\end{definition}

\begin{remark}
Решение о том, является ли вершины особой, принимается независимо в поддереве каждого корня. Одна и та же вершина может быть особой в поддереве одного корня и не являться таковой в поддереве другого корня. Пример такой ситуации отображен на Рисунке 1.
\end{remark}

\begin{definition}
Пусть дан ориентированный граф...
\end{definition}

\begin{remark}
Если дано две особых вершины под одним корнем, то одна из них всегда будет доминировать над другой.
\end{remark}

\begin{theorem}
Пусть дан ориентированный граф
\end{theorem}
\begin{proof}
Согласно предыдущей теореме, если $v$ доминирует над $u$ под корнем $r$, то вершина $u$ будет достижима из $v$. Тогда ............
\end{proof}


\begin{definition}
Те вершины графа $G(V,E)$, которые не имеют входящих ребер, называются глобальными корнями.
\end{definition}

Рассмотрим две вершины в замыкании глобального корня. Одна з них особая, а другая обычная. Чтобы эти две вершины образовали базис, особая вершины не должна доминировать над обычной. В противном случае обычная вершина могла бы быть опущена как незначимая. В общем случае, если дан набор вершин, мы можем опустить все доминируемые вершины и получить корректный базис.

\begin{figure}[H]
	\begin{center}
		\begin{algorithm}[H]
			\SetAlgoLined
			\SetKwInOut{Input}{Input}
			\SetKwInOut{Output}{Output}
			\Input{$G(v, E)$ -- directed graph, $V$ -- set of nodes, $E$ -- set of edges, \\
                   $n$ -- max number of nodes each blackhole can contain}
			\Output{$Blackholes$ -- 1 to n-node blackhole set of G}

                        $Blackholes = \emptyset, C_0 = \emptyset$ \\
                        \For{$i = 1\ to\ n$} {
                            $P_i = \{v | d_{out}(v) < i\}$  
                            \tcp*[f]{$d_{out}(v)$ is an out degree of $v$} \\
                            \ForEach{$v \in P_i$} {
                                \If{$v \notin C_{i-1}$} {
                                    \If{$at\ least\ one\ of\ direct\  successors\ of\ v\ are\ not\ in\ P_i$} {
                                        $remove\ v\ from\ P_i$\\
                                        $remove\ all\ v's\ predecessors\ from\ P_i$\\
                                    }
                                }
                            }
                        }
                        $C_i = P_i$  \tcp*[f]{$C_i$ -- list of candidates} \\
                        \ForEach{$v \in C_i$} {
                            \If{$|Closure(v)| == i$} {
                                $Blackholes = Blackholes \cup Closure(v)$
                            }
                            \If{$|Closure(v)| >= i$} {
                                $remove\ v\ from\ C_i$ \\
                                $remove\ all\ v's\ predecessors\ from\ C_i$ \\
                            }
                        }
                        \tcc{Apply the brute-force algorithm to $C_i(i)$ --  set of all possible subsets of $C_i$ containing $i$ nodes}
                        \ForEach{$B \in C_i(i)$} {
                            \If{$G(B)\ is\ weakly\ connected$} {
                                \If{$d_{out}(B) == 0$} {
                                    $Blackholes = Blackholes \cup B$ \\
                                }
                            }
                        }
                        \Return $Blackholes$
			\label{alg:iblackhole}
			\caption{iBlackhole}
		\end{algorithm}
	\end{center}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\begin{algorithm}[H]
			\SetAlgoLined
			\SetKwInOut{Input}{Input}
			\SetKwInOut{Output}{Output}
			\Input{$G(V,E)$ -- directed graph}
			\Output{$Blackholes$ -- set of blackholes of different sizes}
                        
                        $Blackhole = \emptyset$\\
                        $Build\ graph\ condensation\ Cond(V',E')$\\
                        \For{$i = 1\ to\ |V'|$} {
                            \ForEach{$B_i \in V'(i)$} {
                                \If{$IsBasis(Cond(V',E'),B_i)$} {
                                    \If{$B_i$\ is\ weakly\ connected} {
                                        $Blackholes = Blackholes \cup B_i$ \\
                                    }
                                }
                            }
                        }
                        \Return $Blackholes$
			\label{alg:topsort}
			\caption{TopSort}
		\end{algorithm}
	\end{center}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\begin{algorithm}[H]
			\SetAlgoLined
			\SetKwInOut{Input}{Input}
			\SetKwInOut{Output}{Output}
			\Input{$G(V,E)$ -- directed acyclic graph (after graph condensation) \\
                                $Cand \subset V$ -- set of nodes, candidate to be basis}
			\Output{$True, if\ Cand\ is\ a\ basis, False\ otherwise$}
                        \tcc{(1) calculate special nodes for every root} 
                        \ForEach{$r \in Roots(G)$} {
                            $Special_r = \emptyset$ \\
                            $build\ topSortOrder_r$ \\
                            \For{$i = 0; i<|topSortOrder_r|; i=i + 1$} {
                                $v = topSortOrder_r[i]$ \\
                                $C_v = Closure(v)$ \\
                                \If{$|C_v| == i$} {
                                    $Special_r = Special_r \cup v$ \\
                                    $maxSpecialIndex_r = max(maxSpecialIndex_r, i)$ \\
                                }
                            }
                        }
			\tcc{(2) check for dominated nodes} 
                        \ForEach{$r \in Roots(G)$} {
                            $maxSpecialIndex_r = -1$ \\
                        }
			\ForEach{$v \in Cand$} {
                            \ForEach{$r \in Roots(G)$} {
                                \If{$v \in Special_r$} {
                                    $vTopSortIndex_r = arg_v (topSortOrder_r)$ \\
                                    $maxSpecialIndex_r = max(maxSpecialIndex_r, vTopSortIndex_r)$ \\
                                }
                            }
			}
			\ForEach{$v \in Cand$} {
                            \ForEach{$r \in Roots(G)$} {
                                \If{$v \in Closure(r)$} {
                                    $vTopSortIndex_r = arg_v (topSortOrder_r)$ \\
                                    \If{$vTopSortIndex_r < maxSpecialIndex_r$} {
                                        \Return $False$ \\
                                    }
                                }
                            }
			}
                        \tcc{(3) check for candidates reachable from one another}
                        \ForEach{$(v, u) \in Cand(G) \times Cand(G)$} {
                            \If{v is reachable from u} {
                                \Return $False$ \\
                            }
                        }
                        \Return $True$
			\label{alg:isbasis}
			\caption{IsBasis}
		\end{algorithm}
	\end{center}
\end{figure}

Алгоритм \ref{alg:isbasis} (IsBasis)  проверяет, является ли набор вершин базисом. Этот алгоритм принимает набор вершин и возвращается True, если данный набор образует базис и False в противном случае. Этот алгоритм используется как составная часть алгоритма \ref{alg:topsort} (TopSort), который перебирает наборы-кандидаты и отфильтровывает некорректные наборы. Если IsBasis возвращает False для кандидата, то этот набор может быть пропущен.

IsBasis действует следующим образом.

В первую очередь нам нужно знать, какие вершины являются особыми. Этот шаг может быть посчитан заранее. Чтобы определеить особые вершины, мы строим топологическую сортировку замыкания для каждого глобального корня. Далее по определению отмечаем особые вершины.

Вторым шагом, если мы находим, что какие-то вепршины доминируемы, то мы опускаем данный набор вершин.

На третьем шаге закончились дешевые методы принятия решения. Проверяем попарную достижимость вершин в наборе. Если найдется хоть одна такая пара, опускаем данный набор вершин.

Если ни одна из предыдущих проверок не ответила False (Опустить), то IsBasis возвращает True. Это значение возвращается в алгоритм TopSort и означает, что мы имеем дело с корректным базисом черной дыры. Для получения черной дыры мы должно, согласно определению, объединить все замыкания базисных вершин. Последним шагом убедимся, что полученное множество является слабо связным, это будет означать, что мы получили черную дыру.

Очевидно, что процесс не оптимален, но исследования демонстрируют его эффективность. Мы успешно избегаем дорогой проверки на слабую связность в большом количестве случаев.

\section{Результаты эксперимента}\label{sec:experimentalresults}

Чтобы показать эффективность нашего подхода, мы провели серию экспериментов.


\begin{theorem}
Пусть дан ориентированный граф
\end{theorem}
\begin{proof}
По определению особой вершины размер замыкания $v$ равен индексу плюс один в $topSortOrder_r$. Рассмотрим все вершины, отличные от $v$ в замыканиии $Closure(v)$. Эти вершины в массиве $topSortOrder_r$ имеют индексы меньше, чем вершина $v$. Отсюда $\forall u \in Closure(v)$ вершина $u$ будет достижима из $v$.
\end{proof}

\begin{theorem}
Let $f$ be a function whose derivative exists in every point, then $f$
is a continuous function.
\end{theorem}

%\theoremstyle{definition}
\begin{definition}{Fibration}
A fibration is a mapping between two topological spaces that has the homotopy lifting property for every space $X$.
\end{definition}


%
% ---- Bibliography ----
%
\newpage
\bibliographystyle{acm}
\bibliography{biblio}
\addcontentsline{toc}{section}{Список литературы}

\end{document}
